#!/usr/bin/env python3
"""
generator/recursion_manager.py â€” Minimal refinement logic for SSWG MVM

This module implements a very simple refinement step ("recursion manager")
that can be safely used in the MVM:

- Looks at coverage (and optionally composite_score) in workflow["evaluation"]
- If coverage is below a threshold, injects an autogenerated "emergency_response" module
- Bumps the workflow version number
- Adds a note into evaluation metadata

This is intentionally conservative and deterministic so it can run in CI
and local tests without any LLM dependencies.
"""

from __future__ import annotations

import copy
import logging
from typing import Any, Dict, List

logger = logging.getLogger("generator.recursion_manager")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter("%(levelname)s: %(message)s"))
logger.addHandler(handler)


def increment_version(version: str) -> str:
    """
    Increment a semantic-ish version string.

    Examples:
        "0.1.0" -> "0.1.1"
        "0.0"   -> "0.0.1"
        "1"     -> "1.0.1"
    """
    parts = version.split(".")
    # Normalize to 3 segments
    while len(parts) < 3:
        parts.append("0")
    try:
        parts[-1] = str(int(parts[-1]) + 1)
    except ValueError:
        parts[-1] = "1"
    return ".".join(parts)


def _needs_emergency_module(evaluation: Dict[str, Any]) -> bool:
    """
    Decide whether to auto-inject an emergency module based on coverage score.

    The threshold is intentionally simple for MVM; can be replaced later by
    a learned policy or a configurable rule.
    """
    cov = evaluation.get("coverage", 0.0) or 0.0
    try:
        cov = float(cov)
    except Exception:
        cov = 0.0
    return cov < 0.9


def _emergency_module_exists(modules: List[Dict[str, Any]]) -> bool:
    for m in modules:
        if m.get("module_id") == "mX_emergency_response":
            return True
    return False


def simple_refiner(workflow: Dict[str, Any]) -> Dict[str, Any]:
    """
    Minimal refinement step for the MVM.

    Logic:
    - Clone the workflow to avoid mutating the input
    - If coverage < 0.9 and there is no emergency module yet:
        - Append an autogenerated "emergency_response" module
        - Increment version
        - Annotate evaluation notes

    This is a placeholder hook: in later versions, it can be replaced
    or extended by a full recursive refinement engine that:
      - generates candidate variants
      - scores them
      - selects best according to multi-objective optimization
    """
    wf = copy.deepcopy(workflow)
    modules = wf.setdefault("modules", [])
    evaluation = wf.setdefault("evaluation", {})
    notes = evaluation.setdefault("notes", [])

    if not _needs_emergency_module(evaluation):
        logger.info("Coverage threshold satisfied; no refinement needed.")
        return wf

    if _emergency_module_exists(modules):
        logger.info("Emergency module already present; no additional refinement.")
        return wf

    logger.info("Coverage below threshold; injecting autogenerated emergency module.")

    emergency_module = {
        "module_id": "mX_emergency_response",
        "phase_id": "phase_1",
        "name": "Emergency Response (autogenerated)",
        "inputs": [],
        "outputs": ["emergency_plans"],
        "dependencies": [],
        "dependency_optional": True,
        "ai_logic": (
            "Autogenerated: outline steps to take if fire conditions become unsafe "
            "(e.g., high wind, spreading embers, nearby hazards)."
        ),
        "human_actionable": (
            "Monitor weather and surroundings. If conditions become dangerous, "
            "immediately stop adding fuel, begin extinguishing the fire, and follow "
            "emergency procedures for evacuation or contacting authorities."
        ),
    }

    modules.append(emergency_module)

    old_version = wf.get("version", "0.0.0")
    wf["version"] = increment_version(old_version)

    notes.append(
        "Autogenerated emergency_response module inserted due to coverage < 0.9 "
        f"(version {old_version} -> {wf['version']})."
    )

    logger.info(
        "Refinement applied: added %s and bumped version from %s to %s",
        emergency_module["module_id"],
        old_version,
        wf["version"],
    )

    return wf
